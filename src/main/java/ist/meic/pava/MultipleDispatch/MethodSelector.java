package ist.meic.pava.MultipleDispatch;

import java.lang.reflect.Method;
import java.util.Comparator;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.*;

/**
 * A generic method selector designed to aid runtime dispatch implementations.
 *
 * It operates in two stages:
 *  - find all candidate methods applicable to the given receiver, name and arguments;
 *  - select the most useful method (according to a predefined ordering).
 *
 * Both the candidate method source and comparator are configurable.
 * When only a partial comparator is available, it will be transformed into a full total order.
 * See constructor documentation for more details.
 */
public class MethodSelector {
    private Comparator<Method> comparator;
    private CandidateMethodFinder candidateSource;

    /**
     * Creates a new MethodSelector with the given method comparator and candidate
     * method source.
     *
     * Out of all methods generated by the candidate source, the greatest, as defined
     * by the method comparator, will be selected.
     *
     * @param comparator method comparator
     * @param candidateSource candidate method source
     * @see CandidateMethodFinder
     */
    public MethodSelector(Comparator<Method> comparator, CandidateMethodFinder candidateSource) {
        this.comparator = comparator;
        this.candidateSource = candidateSource;
    }

    /**
     * Creates a new MethodSelector instance with the given method (partial) comparator
     * and the given candidate method source.
     *
     * The partial comparator will be wrapped in a normal Comparator, which will enforce
     * a total order by comparing any otherwise-incomparable methods string representations.
     *
     * Out of all methods generated by the candidate source, the greatest, as defined
     * by the method comparator, will be selected.
     *
     * @param partialComparator method partial comparator
     * @param candidateSource candidate method source
     * @see PartialComparator
     * @see CandidateMethodFinder
     */
    public MethodSelector(PartialComparator<Method> partialComparator, CandidateMethodFinder candidateSource) {
        this(makeTotalOrder(partialComparator), candidateSource);
    }

    /**
     * Creates a new MethodSelector instance with the given method (partial) comparator.
     *
     * The partial comparator will be wrapped in a normal Comparator, which will enforce
     * a total order by comparing any otherwise-incomparable methods string representations.
     *
     * Out of all methods generated by SimpleCandidateMethodSource, the greatest,
     * as defined by the method comparator, will be selected.
     *
     * @param partialComparator method partial comparator
     * @see PartialComparator
     * @see SimpleCandidateMethodFinder
     */
    public MethodSelector(PartialComparator<Method> partialComparator) {
        this(partialComparator, new SimpleCandidateMethodFinder());
    }

    /**
     * Selects the best method for the given receiver, name and arguments.
     *
     * It operates in two stages:
     *  - find all candidate methods applicable to the given receiver, name and arguments;
     *  - select the most useful method (according to a predefined ordering).
     *
     * The algorithms controlling candidate method finding and comparison can be
     * selected during the construction of the MethodSelector instance.
     *
     * @param receiverClass the class of the receiver object.
     * @param name name of the method to call.
     * @param args call arguments.
     * @return the selected Method
     * @throws NoSuchMethodException if no matching method could be found.
     */
    public Method selectMethod(Class<?> receiverClass, String name, Object... args) throws NoSuchMethodException {
        return candidateSource.findCandidates(receiverClass, name, args)
            .max(comparator)
            .orElseThrow(() -> buildNoSuchMethodException(receiverClass, args));
    }

    /**
     * Given an array of objects, returns an array of the corresponding classes (1:1 mapping).
     *
     * @param objects an array of objects
     * @return array with each object's Class
     */
    public static Class<?>[] getObjectTypes(Object[] objects) {
        List<Class<?>> objectTypesList = Arrays.stream(objects)
            .map(Object::getClass)
            .collect(Collectors.toList());

        Class<?>[] objectTypes = new Class[objectTypesList.size()];
        objectTypes = objectTypesList.toArray(objectTypes);

        return objectTypes;
    }


    /**
     * Builds a NoSuchMethodException for the given receiver type and arguments.
     * @param receiverType the type of the receiver.
     * @param args the arguments supplied to the method.
     * @return NoSuchMethodException with the corresponding message.
     */
    private static NoSuchMethodException buildNoSuchMethodException(Class<?> receiverType, Object[] args) {
        return new NoSuchMethodException(buildNoSuchMethodExceptionMessage(receiverType, args));
    }

    /**
     * Prettifies the method signature in format receiverType(arg1Type, arg2Type, ...).
     * @param receiverType the type of the receiver.
     * @param args the arguments supplied to the method.
     * @return the prettified string.
     */
    private static String buildNoSuchMethodExceptionMessage(Class<?> receiverType, Object[] args) {
        // Get class type of each Object in args
        final Class<?>[] argTypes = getObjectTypes(args);

        return receiverType.getName() +
                '(' +
                Arrays.stream(argTypes)
                        .map(Class::getName)
                        .collect(Collectors.joining(", ")) +
                ')';
    }

    /**
     * Transforms a partial method ordering into a total one, by disambiguating
     * otherwire-incomparable cases by their string representations.
     *
     * The resulting ordering is always compatible with the given partial ordering.
     *
     * @param partialComparator partial method comparator
     * @return method comparator
     */
    private static Comparator<Method> makeTotalOrder(PartialComparator<Method> partialComparator) {
        return (lhs, rhs) -> {
            PartialOrdering partialOrd = partialComparator.compare(lhs, rhs);

            if (partialOrd == PartialOrdering.INCOMPARABLE) {
                // disambiguate with string representations
                return lhs.toString().compareTo(rhs.toString());
            } else {
                return partialOrd.asTotalOrdering();
            }
        };
    }

    /**
     * Represents a candidate method finder.
     *
     * Given a receiver, name and arguments, finds all applicable methods,
     * also known as candidate methods.
     *
     * Applicability is left to each implementation of this interface to define.
     *
     * @see SimpleCandidateMethodFinder for a sample basic implementation
     */
    @FunctionalInterface
    public static interface CandidateMethodFinder {
        /**
         * Given a receiver, name and arguments, finds all applicable methods,
         * also known as candidate methods.
         *
         * Applicability is left to each implementation of this interface to define.
         *
         * @param receiverClass the class of the receiver which declares the method.
         * @param name name of the method to call.
         * @param args method call arguments.
         * @return stream of candidate methods
         */
        public Stream<Method> findCandidates(Class<?> receiverClass, String name, Object[] args);
    }

}
